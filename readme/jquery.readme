## OBJX

// get results, add objx methods
     this.contactIds = objx(contacts.data);

// once object has objx methods, use objx's .each method to traverse the tree items, using binding so the internal function has access to the outside world
     this.contactIds.each(objx.bind(function(item, i){              
          this.add(item);
     }, this));


## Single-line if-else javascript

variable = (condition) ? true-value : false-value;

## Regex Modify

/*** Start of Modify ***/
function ltrim(str){
    /* Trims leading spaces - returns string
     * Returns trimmed string
     */
    return str.replace(/^\s+/, '');
}//eof - ltrim

function rtrim(str) {
    /* Trims trailing spaces - returns string
     * Returns trimmed string
     */
    return str.replace(/\s+$/, '');
}//eof - rtrim

function alltrim(str) {
    /* Trims leading and trailing spaces
     * Returns trimmed string
     */
    return str.replace(/^\s+|\s+$/g, '');
}//eof - alltrim

function padleft(str, ch, num) {
    /* Pads string on left with number characters
     * Args:
     *    str = string to pad
     *    ch = pad character
     *    num = number of total characters in final string
     * returns string
     */
        ch = ch || " "; //otherwise pad.length remains 0.
    
        //Create pad string num chars
    var pad = "";
    do  {
        pad += ch;
    } while(pad.length < num);

    //Regular express take num chars from right
    var re = new RegExp(".{" + num + "}$")[0];

    return re.exec(pad + str);
}//eof - padleft

function padright(str, ch, num){
    /* Pads string on right with number characters
     * Args:
     *    str = string to pad
     *    ch = pad character
     *    num = number of total characters in final string
     * returns string
     */
        ch = ch || " "; //otherwise pad.length remains 0.

    //Create pad string num chars
    var pad = "";
        do {
        pad += ch;
    } while (pad.length < num);

    //Regular express take num chars from left
    var re = new RegExp("^.{" + num + "}");
    return re.exec(str + pad)[0];
}//eof - padright

function padcenter(str, ch, size, extra2right) {
    /* Centers string in a string by padding on right and left
     * Args:
     *    str = string to center
     *    ch = pad character
     *    size = number of total characters in final string
         *    extra2right = optional true if extra character should be on right
     * returns string
     */
    var padStr = "";
        var re;
        var len = str.length;
        var rtrnVal;

        if (len <= size) {
                if (extra2right)
                        re = new RegExp("^(.*)(.{" + len + "})(\\1)");
                else
                        re = new RegExp("(.*)(.{" + len + "})(\\1)$");

                do {
                        padStr += ch;
                } while (--size);
                
                rtrnVal = padStr.replace(re, "$1" + str +"$3");
        } else {
                rtrnVal = extractMiddle(str, size, extra2right);
        }
        return rtrnVal;
}//eof padcenter

function centerInStr(inStr, outStr, extra2right) {
    /* Centers string in a string of same characters
     * Args:
     *    inStr = string to center
     *    outStr = string of same character 
         *    extra2right = optional true if extra character should be on right
     * returns string
     */
    var padStr = "";
        var re;
        var len = inStr.length;
        var size = outStr.length;
        var rtrnVal;

        if (len <= size) {
                if (extra2right)
                        re = new RegExp("^(.*)(.{" + len + "})(\\1)");
                else
                        re = new RegExp("(.*)(.{" + len + "})(\\1)$");

                rtrnVal = outStr.replace(re, "$1" + inStr +"$3");
        } else {
                rtrnVal = extractMiddle(inStr, size, extra2right);
        }
        return rtrnVal;
}//eof centerInStr

function centerInStr2(inStr, outStr, extra2right) {
    /* Centers string in a string of mixed characters replacing characters
     * Args:
     *    inStr = string to center within outStr
         *    outStr = the outer string
         *    extra2right = optional true if extra character should be on right
     * returns string
     */
        var inSize = inStr.length;
        var outSize = outStr.length;
    var l = Math.floor( (outSize - inSize) /2);
    var re;
        var rtrnVal;

        if (inSize <= outSize) {
                if (extra2right)
                        re = new RegExp("(.{"+l+"})(.{" + inSize + "})(.*)");
                else
                        re = new RegExp("(.*)(.{" + inSize + "})(.{"+l+"})");

                rtrnVal = outStr.replace(re, "$1" + inStr + "$3");
        } else {
                rtrnVal = extractMiddle(inStr, outSize, extra2right);
        }

        return rtrnVal;
}//eof centerInStr2

function centerInStr3(inStr, outStr, extra2right) {
    /* Centers string in a mixed string without replacing characters
     * Args:
     *    inStr = string to center within outStr
         *    outStr = the outer string
         *    extra2right = optional true if extra character should be on right
     * returns string
     */
    var outSize = outStr.length;
        var inSize = inStr.length;
    var l = Math.floor(outSize/2);
        var re;
        var rtrnVal;

        if (inSize <= outSize) {
                if (extra2right)
                        re = new RegExp("(.{" + l + "})(.*)");
                else
                        re = new RegExp("(.*)(.{" + l + "})");

                rtrnVal = outStr.replace(re, "$1" + inStr + "$2");
        } else {
                rtrnVal = extractMiddle(inStr, outSize, extra2right);
        }
        return rtrnVal;
}//eof centerStr3

function extractMiddle(str, size, extra2right) {
    /* Centers string in a string by padding on right and left
     * Args:
     *    inStr = string to center within outStr
         *    outStr = the outer string
         *    extra2right = optional true if extra character should be on right
     * returns string
     */
        var l = Math.floor( (str.length - size)/2);
        var re;

        if (extra2right)
                re = new RegExp("(.{" + l + "})(.{" + size + "})(.*)");
        else
                re = new RegExp("(.*)(.{" + size + "})(.{" + l + "})");

        return str.replace(re, "$2");
}//eof extractMiddle

function back2forward(dataStr){ 
        return dataStr.replace(/\\/g, "/");
}

function forward2back(dataStr) { 
        return dataStr.replace(/\//g, "\\");
}

function return2br(dataStr) {
    /* Convert returns in string to html breaks
     * return string
     */
    return dataStr.replace(/(\r\n|[\r\n])/g, "<br />");
}//eof - return2br
function return2br2(dataStr) {
    /* Convert returns in string to html breaks
     * return string
     */
    return dataStr.replace(/(\r\n|\r|\n)/g, "<br />");
}//eof - return2br2

function cleanString(str) {
    /* Remove specified characters from string
     * Arg: str = string to clean
     * List is left parenthesis, right parenthesis, period, dash, space
     * Change list inside square brackets [list]
     * Return string
     */
    return str.replace(/[\(\)\.\-\s,]/g, "");
}//eof - cleanString

function cleanString2(str) {
        return str.replace(/[^\d]/g, "");
}

function alpha2numericPhone(phoneStr) {
        var newStr = phoneStr.replace(/[a-zA-Z]/g, alpha2number);
        return checkReplaceParm(newStr, "alpha2number");

        function alpha2number(char) {
                var rtrnVal = null;

                switch (char.toLowerCase()) {
                case "a": case "b": case "c":
                        rtrnVal = "2";
                        break;
                case "d": case "e": case "f":
                        rtrnVal = "3";
                        break;
                case "g": case "h": case "i":
                        rtrnVal = "4";
                        break;
                case "j": case "k": case "l":
                        rtrnVal = "5";
                        break;
                case "m": case "n": case "o":
                        rtrnVal = "6";
                        break;
                case "p": case "q": case "r": case "s":
                        rtrnVal = "7";
                        break;
                case "t": case "u": case "v":
                        rtrnVal = "8";
                        break;
                case "w": case "x": case "y": case "z":
                        rtrnVal = "9";
                        break;
                }
                return rtrnVal;
        }
}

function first_first(name) {
        return name.replace(/^([^,]*)[,\s]+(\w+)/, "$2 $1");
}

function last_first (name) {
        return name.replace(/(.+)\s+([\w']+)$/, "$2, $1"); //'
}

function switchWords(name) {
    /* Change order of two words removing optional comma separator
     * Arg: name = string of two words
     * Return string no separator
     */
    return name.replace(/(\w+),?\s*(\w+)/, "$2 $1");
}//eof - switchWords

function reversOrder (name) {
    /* Change order of two words inserting comma separator
     * Args: name = string of two words
     * Return string with separator
         */

    return name.replace(/(\w+),?\s+(\w+)/, "$2, $1");
}//eof - reversOrder

function cnvrt2upper(str) {
    /* Convert string to title case capital first letters
     * Return converted string or original string if not supported
     */
    str = alltrim(str);
        var newStr = str.toLowerCase().replace(/\b[a-z]/g, cnvrt)

    return checkReplaceParm(newStr, "cnvrt");

    function cnvrt() {
        return arguments[0].toUpperCase();
    }
}//eof - cnvrt2upper

function titleCase(str) {
    str = alltrim(str);
        var newStr = str.toLowerCase().replace(/\b\w+\b/g, cnvrt);
    return checkReplaceParm(newStr, "cnvrt");

    function cnvrt() {
        /*Branch which should be capitalized */
        if (arguments[arguments.length -2] == 0)
            /* First word capitalize if first char is letter*/
            return arguments[0].replace(/^[a-z]/, cnvrt2);
        else if (/^(a|about|after|an|and|at|by|for|from|in|into|nor|of|on|onto|over|the|to|up|with|within)$/.test(arguments[0]) )
            /* List of words to skip */
            return arguments[0];
        else
            /* All other capitalize if first character is letter */
            return arguments[0].replace(/^[a-z]/, cnvrt2);
    }

    function cnvrt2() {
        /* Capitalize letter */
        return arguments[0].toUpperCase();
    }
}//eof
function titleCase2(str) {
        var re = new RegExp(/^(a|about|after|an|and|at|by|for|from|in|into|nor|of|on|onto|over|the|to|up|with|within)$/);               

        return str.toLowerCase().replace(/\b([a-z])(\w*)\b/g, cnvrt);

    function cnvrt() {
        if (re.test(arguments[0]) && arguments[arguments.length-2])
                return arguments[0];
        else
                        return arguments[1].toUpperCase() + arguments[2];
        }
}
function html2entity(str) {
    /* Convert html <,> to &tl; and &gt;
     * Agr: str = string that may have html
     * Return converted string or original string if not supported
     */
        var newStr = cnvrt(str);
    return checkReplaceParm(newStr, "(s)");

    function cnvrt(str){
        //replace with function
        return str.replace(/[<>]/g, function (s){ return (s == "<")? "&lt;" :"&gt;"});
    }
}//eof - html2entity

function checkReplaceParm(str, fx) {
        /* Check browser supports functions in replace
         * No support returns function itself
         */
        var re = new RegExp("^\sfunction\s+" + fx);
        if (re.test(str)) {
                /* This return can be change to null or
                 * a value of your choice to indicate failure
                 */
                alert("This browser doesn't support using a function as an argument to the replace method!");
                return ""
        }
        else {
                return str;
        }
}

## Regex Parse

/** regexp-parsing-data.js ***/
function xtractReportType1(data) {
    /* Approach 1 to extracting data from a string and putting it in another string
     * Arg: data = source data
     * Return new string
     * This fx is of no value accept as a demo.
     * Watchout for dashes
     */
    var array = data.match(/\b[\S]+\b/g);
    return array[5] + " " + array[0] + " paint retail price: $" + array[2] + " ea.";
}//eof - xtractReportType1

function xtractReportType2(data){
    /* Approach 2 to extracting data from a string and putting it in another string
     * Arg: data = source data
     * Return new string
     * This fx is of no value accept as a demo, and not recommended option.
     */
    data.match(/^(\S+)\s(\S+)\s(\S+)\s(\S+)\s(\S+)\s(\S+)\b/);
    return RegExp.$6 + " " + RegExp.$1 + " paint retails for $" + RegExp.$3 + " ea.";
}//eof - xtractReportType2

function xtractNums(str){
    /* Create array of numbers in string
     * Arg: str = source string containing numbers
     *        can be mixed with words.
     * Return array of numbers in str
     * Unlike the previous two, you can use this
     */
    return str.match(/\d+/g);
}//eof - xtractNums

function xtractFormattedNums(data) {
    /* Create array of numbers in string (including formatted with commas and decimal)
     * Arg: data = source string containing numbers
     *        can be mixed with words.
     * Return array of numbers in str
     */
    return data.match(/\d+(,\d{3})*(\.\d{1,2})?/g);
}//eof - xtractFormattedNums

function parseUrl(url) {
    /* Parse URL into protocol, host, path, file and hash (and url)
     *    must be URL only
     * Args: url
     * Return object or null if no match
     */

    url = url.replace(/^\s+|\s+$/g, ''); //alltrim

    if (url.match(/^((http|ftp):\/)?\/?([^:\/\s]+)((\/\w+)*\/)([\w\-\.]+\.[^#?\s]+)(#[\w\-]+)?$/)) {
        //RegExp['$&'] is null in some browsers s/b original url
        return  {url: RegExp['$&'], protocol: RegExp.$2,host:RegExp.$3,path:RegExp.$4,file:RegExp.$6,hash:RegExp.$7};
    }
    else {
        return null;
    }
}//eof - parseUrl

function parseEmeddedUrl(url) {
    /* Parse URL into protocol, host, path, file and hash (and url)
     *        can be embedded in string
     * Args: url
     * Return object or null if no match
     */
    var e = /((http|ftp):\/)?\/?([^:\/\s]+)((\/\w+)*\/)([\w\-\.]+\.[^#?\s]+)(#[\w\-]+)?/
    if (url.match(e)) {
        //RegExp['$&'] is null in some browsers s/b original url
        return  {url: RegExp['$&'], protocol: RegExp.$2,host:RegExp.$3, path:RegExp.$4,file:RegExp.$6,hash:RegExp.$7};
    }
    else {
        return null;
    }
}//eof - parseEmeddedUrl

function xtractFile(data){
    /* Separate path and filename.ext
     * Arg: string with path and filename
     * Return: object
     */
    if (data.match(/(.*)\/([^\/\\]+\.\w+)$/)) {
        return {path: RegExp.$1, file: RegExp.$2};
    }
    else {
        return {path: "", file: ""};
    }
}//eof - xtractFile

function xtractFile_sans(data){
    /* Separate path and filename leaving extention off
     * Assumes DOS style with only one dot.
     * Arg: string with path and filename
     * Return: object
     */
    if (data.match(/(.*)\/([^\/\\]+)\.\w+$/)) {
        return {path: RegExp.$1, file: RegExp.$2};
    }
    else {
        return {path: "", file: ""};
    }
}//eof - xtractFile_sans

function xtractFile-ext1(data){
    /* Parses filename and extension
     *
     * Returns Object
     */
    data = data.replace(/^\s|\s$/g, "");

    if (/\.\w+$/.test(data)) {
        var m = data.match(/([^\/\\]+)\.(\w+)$/);
        if (m)
            return {filename: m[1], ext: m[2]};
        else
            return {filename: "no file name", ext:null};
    } else {
        var m = data.match(/([^\/\\]+)$/);
        if (m)
            return {filename: m[1], ext: null};
        else
            return {filename: "no file name", ext:null};
    }
}//eof - xtractFile-ext1

function xtractFile-ext2(data){
    /* Parses filename and extension
     *
     * Returns Object
     */
    data = data.replace(/^\s|\s$/g, ""); //trims string

    if (/\.\w+$/.test(data)) }
        if (data.match(/([^\/\\]+)\.(\w+)$/) )
            return {filename: RegExp.$1, ext: RegExp.$2};
        else
            return {filename: "no file name", ext:null};
    }
    else {
        if (data.match(/([^\/\\]+)$/) )
            return {filename: RegExp.$1, ext: null};
        else
            return {filename: "no file name", ext:null};
    }
}//eof - xtractFile-ext2

function xtractFile-ext4type(data){
    /* Parses filename and extension
     * for specified extenstions
     *
     * Returns Object
     */
    data = data.replace(/^\s|\s$/g, ""); //trims string

    if (data.match(/([^\/\\]+)\.(asp|html|htm|shtml|php)$/i) )
        return {filename: RegExp.$1, ext: RegExp.$2};
    else
        return {filename: "invalid file type", ext: null};
}//eof - xtractFile-ext4type


## Regex Validate Data

/** regexp-validate-data.js **/
function anyChar(str) {
    /* Verify at least one nonspace character
     *    or string of characters
     * Return boolean
     */
    return /\S+/.test(str);
}//eof - anyChar

function anyWord(str) {
    /* Verify at least one word character
     *        or string of word characters
     *        a word character is alpha numeric or underscore
     * Return boolean
     */
    return /\w+/.test(str);
}//eof - anyWord

function any3letters(str) {
    /* At least 3 consecutive letters anywhere in str
     *    case insensitive
     * Return boolean
     */
    return /[a-z]{3}/i.test(str);
}//eof - any3letters

function any10Char(str) {
    /* Verify exactly 10 nonspace character
     * Return string
     */
    if (/^\S{10}$/.test(str))
        return "Valid";
    else if (/\s/.test(str))
        return "Invalid space";
    else if (/^\S{11,}$/.test(str))
        return "Too long!";
    else
        return "Too short!";
}//eof - any10Char

function anyVar10(str) {
    /* Verify valid JavaScript variable name
     *     of exactly 10 characters
     * Return string
     */
    if (/^[a-z$_]\w{9}$/i.test(str))
        return "Valid";
    else if (/^[^a-z$_]/i.test(str))
        return "First Char Not Alpha!";
    else if (/^[a-z$_]\W/i.test(str))
        return "Invalid Character!"
    else if (/^\w{11,}$/.test(str))
        return "Too long!";
    else
        return "Too short!";
}//eof - anyVar10

function anyClass5(str) {
    /* Verify valid CSS class name of at least 5 characters
     * Return string
     */
    if (/^[a-z][a-z0-9\-]{4,}$/i.test(str))
        return "Valid";
    else if (/^[^a-z]/i.test(str))
        return "First Char Not Alpha!";
    else if (/[^a-z0-9\-]/i.test(str))
        return "Invalid Character!";
    else
        return "Too short!";
}//eof - anyClass5

function any4Words(str) {
    /* Verify at least 4 words can be 1 letter or digit
     * Return boolean
     */
    return /(\b[a-z0-9]+\b.*){4,}/i.test(str);
}//eof - any4Words

function three3lettered(str) {
    /* Verify at least 3 words having at least 3 characters
     * Return boolean
     */
    return /(\b[a-z0-9]{3,}\b.*){3,}/i.test(str);
}//eof - three3lettered

function varTest(data) {
    /* Verify valid JavaScript variable name any length
     * Return string
     */
    if (/^[a-z$_][\w$]*$/i.test(data))
        return "Valid JavaScript Name";
    else if (/^[^a-z$_]/i.test(data))
        return "Invalid First Character!";
    else
        return "Invalid Character!";
}//eof - varTest

function classTest(data) {
    /* Verify valid CSS class name any length
     * Return string
     */
    if (/^[a-z][a-z0-9\-]*$/i.test(data))
        return "Valid Class Name";
    else if (/^[^a-z]/i.test(data))
        return "Invalid First Character!";
    else
        return "Invalid Character!";
}//eof - classTest

function phpTest(data) {
    /* Verify valid PHP variable name any length
     * Return string
     */
    if (/^\$[\w]*$/i.test(data))
        return "Valid PHP/Perl Identifier";
    else if (/^[^$]/.test(data))
        return "Invalid First Character!";
    else
        return "Invalid Character!";
}//eof - phpTest

function validate_file(data){
    /* Parses filename and extension
     * for specified extenstions
     *
     * Returns Object
     */
    data = data.replace(/^\s*|\s*$/g, ""); //trims string

    return /^[a-z]\w*\.(asp|html|htm|shtml|php)$/i.test(data)
}//eof - validate_file

/* Three different email tests return boolean */
function isEmail1(data) {
    return /^[a-zA-Z0-9_\-.]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9]+$/i.test(data);
}//eof - isEmail1

function isEmail2(data) {
    return /^[\w.\-]+@[\w\-]+\.[a-zA-Z0-9]+$/i.test(data);
}//eof - isEmail2

function isEmail3(data) {
    //recommended expression: most complete
    return /^([\w]+)(\.[\w]+)*@([\w\-]+)(\.[\w]{2,4})(\.[a-z]{2})?$/i.test(data);
}//eof - isEmail3

function isSSN1(data) {
    /* Validate American SSN requiring dashes
     * Return boolean
     */
    return /^\d{3}-\d{2}-\d{4}$/.test(data);
}//eof - isSSN1

function isSSN2(data) {
    /* Validate American SSN dashes optional
     * Return boolean
     */
    return /^\d{3}-?\d{2}-?\d{4}$/.test(data);
}//eof -isSSN2

function isPhone1(data) {
    /* Validate American phone number: (123) 456-7890
     *    requiring parenthesis, space and dash
     * Return boolean
     */
    return /^\(\d{3}\) \d{3}-\d{4}$/.test(data);
}//eof - isPhone1

function isPhone2(data) {
    /* Validate American phone number: (123) 456-7890
     *    requiring parenthesis and dash
     *    optional space
     * Return boolean
     */
    return /^\([1-9]\d{2}\)\s?\d{3}\-\d{4}$/.test(data);
}//eof - isPhone2

function isPhone3(data) {
    /* Validate American phone number: (123) 456-7890
     *    optional parenthesis, space and dash
     * Return boolean
     */
        return /^\(?([1-9]\d{2})(\) ?|[.-])?(\d{3})[.-]?(\d{4})$/.test(data);
}//eof - isPhone3

function isValidDate(date_string, format) {
        /* Validate string user entered as a date in 
         * 1 of 6 formats
         *      m/d/y           American month, day, year with 2 or 4 digit year
         *      mm/dd/yy        Short American with 2 digit year
         *      mm/dd/yyyy      Long American with 4 digit year
         *      y/m/d           European year, month, day with 2 or 4 digit year
         *      yy/mm/dd        European with 2 digit year
         *      yyyy/mm/dd      European with 4 digit year
         */
        var days = [0,31,28,31,30,31,30,31,31,30,31,30,31];
        var year, month, day, date_parts = null;
        var rtrn = false;

        /* JS Object/Hash table to branch for format */
        var decisionTree = {
                'm/d/y':{
                        're':/^(\d{1,2})[./-](\d{1,2})[./-](\d{2}|\d{4})$/,
                        'month': 1,'day': 2, year: 3
                },
                'mm/dd/yy':{
                        're':/^(\d{1,2})[./-](\d{1,2})[./-](\d{2})$/,
                        'month': 1,'day': 2, year: 3
                },
                'mm/dd/yyyy':{
                        're':/^(\d{1,2})[./-](\d{1,2})[./-](\d{4})$/,
                        'month': 1,'day': 2, year: 3
                },
                'y/m/d':{
                        're':/^(\d{2}|\d{4})[./-](\d{1,2})[./-](\d{1,2})$/,
                        'month': 2,'day': 3, year: 1
                },
                'yy/mm/dd':{
                        're':/^(\d{1,2})[./-](\d{1,2})[./-](\d{1,2})$/,
                        'month': 2,'day': 3, year: 1
                },
                'yyyy/mm/dd':{
                                're':/^(\d{4})[./-](\d{1,2})[./-](\d{1,2})$/,
                                'month': 2,'day': 3, year: 1
                }
        };

        var test = decisionTree[format]; //Get regexp, etc matching format
        if (test) {
                date_parts = date_string.match(test.re); //parse string
                if (date_parts) {
                        year = date_parts[test.year];
                        month = date_parts[test.month];
                        day = date_parts[test.day];

                        //Get number of days in month -- zero for invalid months
                        test = (month == 2 && 
                                        isLeapYear() && 
                                        29 || days[month] || 0);

                        rtrn = 1 <= day && day <= test; //Check day is in range; false for invalid months
                }
        }

        function isLeapYear() {
                return (year % 4 != 0 ? false : 
                        ( year % 100 != 0? true: 
                        ( year % 1000 != 0? false : true)));
        }
        return rtrn;
}//eof isValidDate

## Regex Validate numbers

/* regexp-validate-numbers.js */
function uInteger(str) {
    /* Verify unsigned integer
     *        ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[0-9]+$/.test(str);
}//eof - uInteger

function uInteger2(str) {
    /* Verify unsigned integer
     *        ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^\d+$/.test(str);
}//eof uInteger2

function uInteger3to5(str) {
    /* Verify unsigned integer 3 to 5 digits
     *        ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^\d{3,5}$/.test(str);
}//eof - uInteger3to5

function sInteger(str) {
    /* Verify signed integer at least one digit
     *        ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[-+]?[0-9]+$/.test(str);
}//eof - sInteger

function sInteger2(str) {
    /* Verify signed integer at least one digit
     *        ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[-+]?\d+$/.test(str);
}//eof - sInteger2

function sInteger3to5(str) {
    /* Verify signed integer 3 to 5 digits
     *        ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[-+]?\d{3,5}$/.test(str);
}//eof - sInteger3to5

function isFloat(str) {
    /* Verify signed float decimal optional
     *    ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[-+]?[0-9]+(\.[0-9]+)?$/.test(str);
}//eof isFloat

function isFloat2(str) {
    /* Verify signed float decimal optional
     *    ignoring leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[-+]?\d+(\.\d+)?$/.test(str);
}//eof isFloat2

function isFloat3to5d0to3(str) {
    /* Verify float 3 to 5 digits, decimal max 3 digits
     *    if decimal point must have at least 1 decimal digit
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^[-+]?\d{3,5}(\.\d{1,3})?$/.test(str);
}//eof - isFloat3to5d10to3

function isCurrency1(str) {
    /* Verify formatted currency optional $, no leading zero
     *    reguire comma separator, 2 digit decimal if any
     *    ignore leading and trailing spaces
     * Return boolean
     */
    str = str.replace(/^\s+|\s+$/g, '');
    return /^\$?[1-9][0-9]{0,2}(,[0-9]{3})*(\.[0-9]{2})?$/.test(str);
}//eof - isCurrency1

function isCurrency2(str) {
    /*  Verify formatted currency optional $, no leading zero
     *    reguire comma separator, 2 digit decimal if any
     *    fillin missing decimal
     *    ignore leading and trailing spaces
     * Return string
     */
    str = str.replace(/^\s+|\s+$/g, '');
    if (/^\$?[1-9][0-9]{0,2}(,[0-9]{3})*(\.[0-9]{0,2})?$/.test(str) ) {

        if (/\.[0-9]$/.test(str) ) {
            //needs trailing zero
            str += "0";
        }
        else if (/\.$/.test(str)) {
            //needs both trailing zeroes
            str += "00";
        }
        else if (!/\.[0-9]{2}$/.test(str) ) {
            //needs everything
            str += ".00";
        }
        return str;
    }
    else {
        return "Invalid";
    }
}//eof - isCurrency2

function isCurrency3(str) {
    /* Verify formatted currency optional $, no leading zero
     *    reguire comma separator, 2 digit decimal if any
     *    fillin missing decimal
     *    ignore leading and trailing spaces
     * Return string
     */
    str = str.replace(/^\s+|\s+$/g, '');

    if (/^[-+]?\$?[1-9]\d{0,2}(,\d{3})*(\.\d{0,2})?$/.test(str) ) {

        if (/\.\d$/.test(str)) {
            str += "0";
        }
        else if (/\.$/.test(str) ) {
            str += "00";
        }
        else if (!/\.\d{2}$/.test(str) ) {
            str += ".00";
        }
        return str;
    }
    else {
        return "Invalid";
    }
}//eof - isCurrency3

## Regex replace space to repeating

data.url = data.title.toLowerCase().replace(/ /gi, "-");

## Javascript Best Practices

http://www.javascripttoolbox.com/bestpractices/

## Javascript Reserved Words

abstract (*)
as (2)
boolean
break
byte
case
catch
char
class (2)
continue
const (2)
debugger (*)
default
delete
do
double
else
enum (*)
export (2)
extends (2)
false
final
finally
float
for
function
goto (*)
if
implements (*)
import (2)
in
instanceof
int
interface (2)
is (2)
long
namespace (2)
native (*)
new
null
package (2)
private (2)
protected (*)
public (2)
return
short
static (2)
super (2)
switch
synchronized (*)
this
throw
throws (*)
transient (*)
true
try
typeof
use (2)
var
void
volatile (*)
while
with

## Improve your Jquery

http://www.tvidesign.co.uk/blog/improve-your-jquery-25-excellent-tips.aspx

## window.location.href vs location.href

In article <ncE1d.60335$WH1.1164697@wagner.videotron.net>,
dontwantspam@yahoo.com enlightened us with...[color=blue]
> Hi,
]]>
> Is anyone know what is the difference between Location.href and
> Window.location.href
]]>
> Thanks you very much:)
>[/color]

Javascript is case-sensitive.
window.location.href

There's a window object.
The window object has a location object as one of its properties.
The location object has href as a property.

As to the difference between the two, the difference comes up when it's not
really
window.location.href
but more like
top.location.href

You see a lot of references say window.location.href when what they really
mean is ANY window object.

So the following would all do different things in a nested frameset depending
on exactly where they executed:
self.location.href="default.html";
top.location.href="default.html";
parent.location.href="default.html";
top.frames[2].location.href="default.html";
top.opener.location.href="default.html"; // only for popup

I believe most browsers infer the window object as self if it isn't
specified, but I don't know that that is guaranteed. I myself always specify
the full window.location.href, JIC.